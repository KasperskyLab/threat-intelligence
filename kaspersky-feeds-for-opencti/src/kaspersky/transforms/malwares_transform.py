#!/usr/bin/env python3
#
# Â© 2024 AO Kaspersky Lab. All Rights Reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
"""Kaspersky malwares transform module."""

import json
from typing import Dict, List, Tuple

import stix2
from pycti import Malware

from .transform import Transform
from .utils import (
    LOCATION_ROLE,
    MALWARE_ROLE,
    LocationRoles,
    MalwareRoles,
    build_relationship,
)


def parse_threat_verdict(value: str) -> Dict:
    """
    Parse threat verdict to get details. Format expected to be like
    'prefix:method:behaviour.platform.family.modification' but there
    are could me some variations.
    """
    parts = value.split(":")
    parts_count = len(parts)
    malware_code = parts[-1] if parts_count < 4 else parts[2]

    parts = malware_code.split(".")
    parts_count = len(parts)
    if parts_count == 3:
        return {
            "behaviour": parts[0],
            "platform": parts[1],
            "family": parts[2],
        }

    if parts_count == 4:
        return {
            "behaviour": parts[0],
            "platform": parts[1],
            "family": parts[2],
            "modification": parts[3],
        }

    return None


def format_malware_name(details: Dict, with_modification: bool) -> str:
    """Format malware name for malware object."""
    malware_name = f'{details["behaviour"]}.{details["platform"]}.{details["family"]}'
    if with_modification:
        malware_name = f'{malware_name}.{details["modification"]}'
    return malware_name


def extract_malware_class(malware_name: str) -> Tuple[str, str]:
    """Parse malware class which can be used to estimate relationship between malwares."""
    parts = malware_name.split(".")
    parts_count = len(parts)
    if parts_count not in (3, 4):
        return (None, None)
    malware_class = f"{parts[0]}.{parts[1]}.{parts[2]}"
    malware_modification = parts[3] if parts_count == 4 else None
    return (malware_class, malware_modification)


def is_variant_of(malware: Dict, parent: Dict) -> bool:
    """Determine whether malware object is variant of parent (more generic) malware."""
    is_same = malware["id"] == parent["id"]
    if is_same:
        return False

    malware_class, malware_modification = extract_malware_class(malware["name"])
    if malware_modification is None:
        return False

    parent_class, parent_modification = extract_malware_class(parent["name"])
    if parent_modification is not None:
        return False

    return malware_class == parent_class


def format_description(details: Dict, with_modification: bool) -> str:
    """Format description string for malware object."""
    description = (
        f'behaviour={details["behaviour"]};'
        f'platform={details["platform"]};'
        f'family={details["family"]}'
    )
    if with_modification:
        description = f'{description};modification={details["modification"]}'
    return description


def location_link_type(location_object: Dict) -> str:
    """Estimate relationship link type based on location object attributes."""
    match location_object.get(LOCATION_ROLE, None):
        case LocationRoles.ACTOR:
            return "originates-from"
        case LocationRoles.TARGET:
            return "targets"
        case _:
            return "related-to"


class MalwaresTransform(Transform):
    """Transform for malwares."""

    def build_objects(self, indicator: Dict, context: Dict) -> List[Dict]:
        stix_objects = []
        if "threat" not in context:
            return stix_objects

        details = parse_threat_verdict(context["threat"])
        if details is None:
            return stix_objects

        malware_role = MalwareRoles.REAL_ACTOR
        if "modification" in details:
            malware_name = format_malware_name(details=details, with_modification=True)
            stix_object = stix2.Malware(
                id=Malware.generate_id(name=malware_name),
                name=malware_name,
                is_family=True,
                description=format_description(details=details, with_modification=True),
                created_by_ref=self._author["id"],
            )
            stix_object = json.loads(stix_object.serialize())
            stix_object[MALWARE_ROLE] = malware_role
            malware_role = MalwareRoles.FAKE_GROUP  # attribute for parent object
            stix_objects.append(stix_object)

        malware_name = format_malware_name(details=details, with_modification=False)
        stix_object = stix2.Malware(
            id=Malware.generate_id(name=malware_name),
            name=malware_name,
            is_family=True,
            description=format_description(details=details, with_modification=False),
            created_by_ref=self._author["id"],
        )
        stix_object = json.loads(stix_object.serialize())
        stix_object[MALWARE_ROLE] = malware_role
        stix_objects.append(stix_object)

        return stix_objects

    def build_relationships(self, stix_objects: List[Dict]) -> List[Dict]:
        malwares = filter(
            lambda stix_object: stix_object["type"] == "malware", stix_objects
        )

        relationships = []
        for malware in malwares:
            malware_role = malware.get(MALWARE_ROLE, None)
            if malware_role != MalwareRoles.REAL_ACTOR:
                continue

            for stix_object in stix_objects:
                # pylint: disable-next=duplicate-code
                object_type = stix_object["type"]

                if object_type == "malware":
                    if is_variant_of(malware=malware, parent=stix_object):
                        relationships.append(
                            build_relationship(
                                source=malware,
                                target=stix_object,
                                link_type="variant-of",
                            )
                        )

                elif object_type == "threat-actor":
                    relationships.append(
                        build_relationship(
                            source=malware,
                            target=stix_object,
                            link_type="authored-by",
                        )
                    )

                elif object_type == "location":
                    link_type = location_link_type(stix_object)
                    relationships.append(
                        build_relationship(
                            source=malware,
                            target=stix_object,
                            link_type=link_type,
                        )
                    )

                elif object_type == "identity":
                    identity_class = stix_object["identity_class"]
                    if identity_class == "class":
                        relationships.append(
                            build_relationship(
                                source=malware,
                                target=stix_object,
                                link_type="targets",
                            )
                        )

        return relationships
